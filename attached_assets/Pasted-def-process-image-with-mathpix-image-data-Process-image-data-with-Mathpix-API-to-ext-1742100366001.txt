def process_image_with_mathpix(image_data):
    """
    Process image data with Mathpix API to extract mathematical content, tables, 
    chemical diagrams, and geometric figures
    
    Args:
        image_data (str): Base64-encoded image data
        
    Returns:
        dict: Structured result containing all extracted data
    """
    # Récupérer les clés API depuis les variables d'environnement
    MATHPIX_APP_ID = os.getenv('MATHPIX_APP_ID')
    MATHPIX_APP_KEY = os.getenv('MATHPIX_APP_KEY')
    
    if not MATHPIX_APP_ID or not MATHPIX_APP_KEY:
        logger.error("Identifiants API Mathpix non configurés")
        return {"error": "Identifiants API Mathpix non configurés"}
    
    headers = {
        "app_id": MATHPIX_APP_ID,
        "app_key": MATHPIX_APP_KEY,
        "Content-Type": "application/json"
    }
    
    try:
        # Nettoyer les données base64 si nécessaire
        if isinstance(image_data, str) and "base64," in image_data:
            image_data = image_data.split("base64,")[1]
        
        # Configuration complète pour capturer tous les types de contenu
        payload = {
            "src": f"data:image/jpeg;base64,{image_data}",
            "formats": ["text", "data", "html"],
            "data_options": {
                "include_asciimath": True,
                "include_latex": True,
                "include_mathml": True,
                "include_svg": True,
                "include_tsv": True,          # Pour les tableaux
                "include_table_html": True    # Pour les tableaux formatés
            },
            "include_detected_alphabets": True, # Identifier les alphabets utilisés
            "include_geometry_data": True,    # Pour les figures géométriques
            "include_line_data": True,        # Analyse ligne par ligne
            "include_word_data": True,        # Analyse mot par mot
            "include_smiles": True,           # Pour les formules chimiques
            "include_inchi": True,            # Pour les données chimiques supplémentaires
            "enable_tables_fallback": True    # Pour les tableaux complexes
        }
        
        # Envoyer la requête à Mathpix
        url = "https://api.mathpix.com/v3/text"
        response = requests.post(url, headers=headers, json=payload, timeout=30)
        response.raise_for_status()
        
        result = response.json()
        
        # Analyser et structurer la réponse
        structured_result = {
            "text": result.get("text", ""),
            "has_math": False,
            "has_table": False,
            "has_chemistry": False,
            "has_geometry": False,
            "details": {}
        }
        
        # Traitement des données mathématiques
        if "data" in result:
            for data_item in result["data"]:
                if data_item.get("type") in ["latex", "asciimath", "mathml"]:
                    structured_result["has_math"] = True
                    if "math_details" not in structured_result["details"]:
                        structured_result["details"]["math_details"] = []
                    structured_result["details"]["math_details"].append(data_item)
                
                # Traitement des tableaux
                if data_item.get("type") in ["tsv", "table_html"]:
                    structured_result["has_table"] = True
                    if "table_details" not in structured_result["details"]:
                        structured_result["details"]["table_details"] = []
                    structured_result["details"]["table_details"].append(data_item)
        
        # Traitement des données géométriques
        if "geometry_data" in result and result["geometry_data"]:
            structured_result["has_geometry"] = True
            structured_result["details"]["geometry_details"] = process_geometry_data(result["geometry_data"])
        
        # Vérifier les formules chimiques (SMILES)
        if "text" in result:
            import re
            smiles_pattern = r'<smiles.*?>(.*?)</smiles>'
            smiles_matches = re.findall(smiles_pattern, result["text"])
            
            if smiles_matches:
                structured_result["has_chemistry"] = True
                structured_result["details"]["chemistry_details"] = smiles_matches
        
        # Préparer un résumé formaté pour l'assistant
        formatted_summary = format_mathpix_result_for_assistant(structured_result)
        structured_result["formatted_summary"] = formatted_summary
        
        return structured_result
        
    except Exception as e:
        logger.error(f"Erreur lors du traitement de l'image avec Mathpix: {str(e)}")
        return {"error": f"Erreur lors du traitement de l'image: {str(e)}"}


def format_mathpix_result_for_assistant(result):
    """
    Format le résultat de Mathpix en un résumé textuel bien structuré pour l'assistant
    
    Args:
        result (dict): Résultat structuré de Mathpix
        
    Returns:
        str: Résumé formaté pour l'assistant
    """
    summary = []
    
    # Ajouter un en-tête basé sur le contenu
    content_types = []
    if result["has_math"]: content_types.append("des formules mathématiques")
    if result["has_table"]: content_types.append("des tableaux")
    if result["has_chemistry"]: content_types.append("des formules chimiques")
    if result["has_geometry"]: content_types.append("des figures géométriques")
    
    if content_types:
        summary.append(f"L'image contient {', '.join(content_types)}.")
    
    # Ajouter le texte principal
    if result.get("text"):
        summary.append("\nContenu extrait:")
        summary.append(result["text"])
    
    # Ajouter des détails sur la géométrie si présente
    if result["has_geometry"] and "geometry_details" in result["details"]:
        summary.append("\nDétails de la figure géométrique:")
        summary.append(result["details"]["geometry_details"])
    
    # Ajouter des détails sur les formules chimiques
    if result["has_chemistry"] and "chemistry_details" in result["details"]:
        summary.append("\nFormules chimiques détectées (SMILES):")
        for formula in result["details"]["chemistry_details"]:
            summary.append(f"- {formula}")
    
    # Si tableau présent, le mentionner spécifiquement
    if result["has_table"]:
        summary.append("\nUn tableau a été détecté dans l'image. Les données sont incluses dans le texte ci-dessus.")
    
    return "\n".join(summary)


def process_geometry_data(geometry_data):
    """
    Traite les données géométriques en un format compréhensible
    
    Args:
        geometry_data (list): Données géométriques renvoyées par Mathpix
        
    Returns:
        str: Description formatée des figures géométriques
    """
    if not geometry_data:
        return "Aucune figure géométrique détectée."

    result_parts = ["Figure géométrique détectée:"]

    for figure in geometry_data:
        shape_list = figure.get("shape_list", [])
        label_list = figure.get("label_list", [])

        for shape in shape_list:
            shape_type = shape.get("type", "inconnu")
            result_parts.append(f"- Type: {shape_type}")

            if shape_type == "triangle":
                vertices = shape.get("vertex_list", [])
                result_parts.append(f"- Nombre de sommets: {len(vertices)}")
                
                # Ajouter les coordonnées des sommets
                result_parts.append("- Coordonnées des sommets:")
                for i, vertex in enumerate(vertices):
                    result_parts.append(f"  * Sommet {i+1}: ({vertex.get('x')}, {vertex.get('y')})")

        # Traiter les étiquettes (textes et valeurs)
        if label_list:
            result_parts.append("- Étiquettes détectées:")
            for label in label_list:
                label_text = label.get("text", "")
                position = label.get("position", {})
                result_parts.append(f"  * {label_text} - Position: ({position.get('top_left_x', 'N/A')}, {position.get('top_left_y', 'N/A')})")

    return "\n".join(result_parts)