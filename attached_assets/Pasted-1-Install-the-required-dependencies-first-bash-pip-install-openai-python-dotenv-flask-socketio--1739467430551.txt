1. Install the required dependencies first:
`bash
pip install openai python-dotenv flask-socketio
`

2. Create a secret:
`
OPENAI_API_KEY=your-key-api-openai
OPENAI_ASSISTANT_ID=your-assistant-id-openai
`

3. Modification of `app.py’:

Python
/* TO BE MODIFIED */
from the import of vials, render_template
app = Flask(__name__)
@app.route('/')
def chat():
    # Empty history list
    history = []
    return render_template('chat.html', history=history, credits=42)

/* TO BE REPLACED BY */
from flask import, render_template, request, jsonify
flask_socketio import SocketIO, issue
openai import OpenAI
of the data import loads_data_v
import bone

load_dotenv()

app = Flask(__name__)
socketio = SocketIO(app)
client = OpenAI(api_key=os.getenv('OPENAI_API_KEY'))

# Create wizard (to be done only once)
assistant = client.beta.assistants.create(
    name="Môjo",
    instructions="You are Môjo, a French teacher assistant who helps students in their studies."
    tools=[{"type" : "code_interpreter"}],
    model="gpt-4-turbo-preview"
)

@app.route('/')
def chat():
    history = []
    return render_template('chat.html', history=history, credits=42)

@socketio.on('send_message')
def handle_message(data):
    try:
        # Create thread for conversation
        thread = client.beta.threads.create()
        
        # Add user message
        client.beta.threads.messages.create(
            thread_id=thread.id
            role="user",
            content=data['message']
        )

        # Create a request
        run = client.beta.threads.runs.create(
            thread_id=thread.id
            assistant_id=assistant.id
        )
                # Wait for response
    then it’s true:
        run_status = client.beta.threads.runs.retrieve(
            thread_id=thread.id
            run_id=run.id
        )
        if run_status.status == 'completed:
            break
        elif run_status.status == 'failed':
            emit('receive_message', {'message' : 'Sorry, there was an error.})
            return

    # Retrieve the answer
    messages = client.beta.threads.messages.list(thread.id)
    assistant_message = messages.data[0]. content[0].text.value
    
    emit('receive_message', {'message' : assistant_message})
except exceptions such as:
    emit('receive_message', {'message' : f'Error: {str(e)}})
if name == 'hand':
socketio.run(app, debug=True)

Changes in static/js/main.js:

JavaScript
/* TO BE ADDED */
// Initialize Socket.IO
const socket = io();
// Message Send Manager
sendMessage() function {
const input = document.querySelector('.input-container input');
const message = input.value.trim();
Copyif (message) {
    // Display user message
    const chatMessages = document.querySelector('.chat-messages');
    const messageDiv = document.createElement('div');
    messageDiv.className = user message;
    messageDiv.innerHTML = ‘
        

            
${message}
        
    `
    chatMessages.appendChild(messageDiv);
    
    // Send to server
    socket.emit('send_message', { message: message });
    
    // Clear the entrance
    input.value = '
    
    // Scroll down
    chatMessages.scrollTop = chatMessages.scrollHeight;
}
}
// Écouter les réponses de l’assistant
socket.on('receive_message', function(data) {
const chatMessages = document.querySelector('.chat-messages');
const messageDiv = document.createElement('div');
messageDiv.className = 'assistant de message';
messageDiv.innerHTML =   <div class="message-content">   ${data.message}   </div>   ;
chatMessages.appendChild(messageDiv);
chatMessages.scrollTop = chatMessages.scrollHeight;
});
// Événements d’entrée
document.querySelector('.send-btn'). addEventListener('click', sendMessage);
document.querySelector('. input-container input'). addEventListener('keypress', function(e) {
si (e.key === 'Entrée') {
sendMessage();
}
});