@socketio.on('send_message')
def handle_message(data):
    try:
        # Get current conversation or create a new one if this is the first message
        thread_id = session.get('thread_id')
        conversation = None
        if thread_id:
            conversation = Conversation.query.filter_by(thread_id=thread_id).first()

        if not conversation:
            # Create new conversation for first message
            conversation = get_or_create_conversation()
            session['thread_id'] = conversation.thread_id

        # Variables pour stocker les résultats de Mathpix
        mathpix_result = None
        formatted_summary = None

        # Handle image if present
        if 'image' in data and data['image']:
            try:
                # Save the base64 image
                filename = save_base64_image(data['image'])
                # Create a public URL for the image
                image_url = request.url_root.rstrip('/') + url_for('static', filename=f'uploads/{filename}')

                # ===== AJOUT: Traiter l'image avec Mathpix =====
                mathpix_result = process_image_with_mathpix(data['image'])
                
                # Vérifier si une erreur s'est produite
                if "error" in mathpix_result:
                    logger.error(f"Mathpix error: {mathpix_result['error']}")
                    # Continuer sans l'extraction Mathpix, mais en enregistrant l'erreur
                    formatted_summary = f"L'extraction du contenu de l'image a échoué. Je vais analyser l'image visuellement."
                else:
                    # Utiliser le résumé formaté pour l'assistant
                    formatted_summary = mathpix_result.get("formatted_summary", "")
                    logger.info(f"Mathpix extraction successful. Content types: math={mathpix_result.get('has_math')}, table={mathpix_result.get('has_table')}, chemistry={mathpix_result.get('has_chemistry')}, geometry={mathpix_result.get('has_geometry')}")
                
                # Construire le message utilisateur avec l'extraction de l'image
                user_content = data.get('message', '')
                if formatted_summary:
                    # Si l'utilisateur a aussi envoyé un message textuel
                    if user_content:
                        user_store_content = f"{user_content}\n\n[Contenu extrait de l'image]\n{formatted_summary}"
                    else:
                        user_store_content = f"[Contenu extrait de l'image]\n{formatted_summary}"
                else:
                    user_store_content = user_content
                
                # Store user message with image and extracted content
                user_message = Message(
                    conversation_id=conversation.id,
                    role='user',
                    content=user_store_content,
                    image_url=image_url
                )
                db.session.add(user_message)

                # Create message for OpenAI with image and extracted content
                openai_message_content = []

                # Add image content
                openai_message_content.append({
                    "type": "image_url",
                    "image_url": {
                        "url": image_url
                    }
                })

                # ===== MODIFICATION: Créer un message enrichi pour l'assistant =====
                message_for_assistant = ""
                
                # Ajouter le message de l'utilisateur en premier s'il existe
                if data.get('message'):
                    message_for_assistant += f"{data['message']}\n\n"
                
                # Ajouter les résultats de l'extraction Mathpix
                if formatted_summary:
                    message_for_assistant += formatted_summary
                else:
                    # Message par défaut si aucune extraction
                    if not data.get('message'):  # Seulement si l'utilisateur n'a pas fourni de message
                        message_for_assistant = "Veuillez analyser cette image."

                # Add text content with Mathpix extraction
                openai_message_content.append({
                    "type": "text",
                    "text": message_for_assistant
                })

                # Send message to OpenAI with image URL and extracted text
                client.beta.threads.messages.create(
                    thread_id=conversation.thread_id,
                    role="user",
                    content=openai_message_content
                )
            except Exception as img_error:
                logger.error(f"Image processing error: {str(img_error)}")
                raise Exception("Failed to process image. Please make sure it's a valid image file.")
        else:
            # Store text-only message
            user_message = Message(
                conversation_id=conversation.id,
                role='user',
                content=data.get('message', '')
            )
            db.session.add(user_message)

            # Send message to OpenAI
            client.beta.threads.messages.create(
                thread_id=conversation.thread_id,
                role="user",
                content=data.get('message', '')
            )

        # Create and run assistant
        run = client.beta.threads.runs.create(
            thread_id=conversation.thread_id,
            assistant_id=ASSISTANT_ID
        )

        # Wait for response with timeout
        timeout = 30
        start_time = time.time()

        while True:
            if time.time() - start_time > timeout:
                emit('receive_message', {'message': 'Request timed out.'})
                return

            run_status = client.beta.threads.runs.retrieve(
                thread_id=conversation.thread_id,
                run_id=run.id
            )

            if run_status.status == 'completed':
                break
            elif run_status.status == 'failed':
                emit('receive_message', {'message': 'Sorry, there was an error.'})
                return

            eventlet.sleep(1)

        # Retrieve and store assistant's response
        messages = client.beta.threads.messages.list(thread_id=conversation.thread_id)
        assistant_message = messages.data[0].content[0].text.value

        # Store assistant response in database
        db_message = Message(
            conversation_id=conversation.id,
            role='assistant',
            content=assistant_message
        )
        db.session.add(db_message)

        # Generate and set conversation title if this is the first message
        if not conversation.title:
            first_user_message = Message.query.filter_by(
                conversation_id=conversation.id,
                role='user'
            ).order_by(Message.created_at).first()

            if first_user_message:
                # Utiliser les 30 premiers caractères du message sans le texte extrait de l'image 
                # pour un titre plus propre
                raw_content = data.get('message', '') or "Image"
                title = raw_content[:30] + "..." if len(raw_content) > 30 else raw_content
                
                # Si c'est juste une image sans texte utilisateur, créer un titre plus descriptif
                if not data.get('message') and mathpix_result:
                    content_types = []
                    if mathpix_result.get("has_math"): content_types.append("math")
                    if mathpix_result.get("has_table"): content_types.append("table")
                    if mathpix_result.get("has_chemistry"): content_types.append("chemistry")
                    if mathpix_result.get("has_geometry"): content_types.append("geometry")
                    
                    if content_types:
                        title = f"Image ({', '.join(content_types)})"
                    else:
                        title = "Image"
                
                conversation.title = title
                db.session.commit()

                # Emit the new conversation to all clients for real-time history update
                emit('new_conversation', {
                    'id': conversation.id,
                    'title': conversation.title,
                    'subject': 'Général',
                    'time': conversation.created_at.strftime('%H:%M')
                }, broadcast=True)

        db.session.commit()

        # Send response to client
        emit('receive_message', {'message': assistant_message})

    except Exception as e:
        logger.error(f"Error in handle_message: {str(e)}")
        error_message = str(e)
        if "image" in error_message.lower():
            emit('receive_message', {'message': 'Error processing image. Please ensure the image is in a supported format (JPG, PNG, GIF) and try again.'})
        else:
            emit('receive_message', {'message': f'An error occurred while processing your message. Please try again.'})