import os
import hmac
import hashlib
import logging
import requests
import time
import eventlet
from flask import Blueprint, request, jsonify, session
from datetime import datetime
from database import db
from openai import OpenAI, BadRequestError, APIError
from mathpix_utils import process_image_with_mathpix
from sqlalchemy import Index, desc, BigInteger, Text
import sys
from threading import Lock, Thread
from queue import Queue
from collections import defaultdict
from app import socketio
from models import User, UserMemory
from models import WhatsAppMessage
# Import de la configuration IA centralisée
from ai_config import (
    get_ai_client,
    get_model_name,
    get_system_instructions,
    ASSISTANT_ID,
    CONTEXT_MESSAGE_LIMIT,
    openai_client as client
)
from utils import db_retry_session
from ai_utils import prepare_messages_for_api, upload_image_to_openai, process_image_for_openai
from config import Config
from utils import clean_response

_message_queues = defaultdict(Queue)      # Queue par thread_id
_processing_threads = {}                   # Thread worker par thread_id
_dict_lock = Lock()                        # Pour synchroniser l'accès aux dicts

# Configure logging
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

# Create Blueprint for WhatsApp routes
whatsapp = Blueprint('whatsapp', __name__)

def get_or_create_thread(phone_number, force_new=False):
    """Get existing thread or create new one for a phone number"""
    try:
        from ai_config import CURRENT_MODEL
        current_model = CURRENT_MODEL

        logger.info(f"Recherche/création de thread pour {phone_number} avec modèle: {current_model}")

        # Cas simple: si on force un nouveau thread, on le crée et on l'utilise
        if force_new:
            thread_id = None
            # Créer un vrai thread OpenAI seulement si le modèle actuel est OpenAI
            if current_model == 'openai':
                thread = client.beta.threads.create()
                thread_id = thread.id
                logger.info(f"Création forcée d'un nouveau thread OpenAI {thread_id} pour {phone_number}")
            else:
                # Pour les autres modèles, utiliser un format local
                thread_id = f"thread_{phone_number}_{int(time.time())}"
                logger.info(f"Création forcée d'un nouveau thread local {thread_id} pour {phone_number}")

            # Émettre l'événement si c'est un nouvel utilisateur
            try:
                is_new_user = WhatsAppMessage.query.filter_by(from_number=phone_number).count() == 0
                if is_new_user:
                    from app import socketio
                    user_data = {
                        'name': f'WhatsApp User {phone_number}',
                        'phone': phone_number,
                        'platform': 'whatsapp',
                        'created_at': datetime.now().strftime('%d/%m/%Y')
                    }
                    socketio.emit('new_whatsapp_user', user_data)
            except Exception as event_error:
                logger.error(f"Erreur d'émission d'événement: {str(event_error)}")

            return thread_id

        # Chercher le thread existant le plus récent
        message = WhatsAppMessage.query.filter(
            WhatsAppMessage.from_number == phone_number,
            WhatsAppMessage.thread_id.isnot(None)
        ).order_by(WhatsAppMessage.timestamp.desc()).first()

        # Si un thread existe, l'utiliser - sauf cas particuliers
        if message and message.thread_id:
            existing_thread_id = message.thread_id
            is_local_thread = existing_thread_id.startswith("thread_")

            # On ne peut pas se fier uniquement au préfixe "thread_" car les vrais threads OpenAI 
            # commencent également par "thread_". Test: on essaie d'utiliser le thread directement
            if current_model == 'openai':
                try:
                    # Tester si le thread est utilisable avec OpenAI
                    test_response = client.beta.threads.messages.list(thread_id=existing_thread_id, limit=1)
                    # Si on arrive jusqu'ici, le thread est valide
                    logger.info(f"Thread OpenAI existant {existing_thread_id} vérifié avec succès")
                    return existing_thread_id
                except Exception as e:
                    # Le thread n'est pas utilisable avec OpenAI, créer un nouveau thread
                    logger.info(f"Thread {existing_thread_id} non utilisable avec OpenAI ({str(e)}), création d'un nouveau thread")
                    thread = client.beta.threads.create()
                    thread_id = thread.id
                    logger.info(f"Nouveau thread OpenAI créé: {thread_id}")
                    return thread_id

            # Si on a un thread OpenAI et que le modèle est aussi OpenAI, vérifier qu'il existe toujours
            if not is_local_thread and current_model == 'openai':
                try:
                    # Test si le thread OpenAI existe
                    client.beta.threads.messages.list(thread_id=existing_thread_id, limit=1)
                    logger.info(f"Utilisation du thread OpenAI existant {existing_thread_id}")
                    return existing_thread_id
                except Exception as e:
                    logger.warning(f"Thread OpenAI {existing_thread_id} invalide: {str(e)}")
                    # Créer un nouveau thread si celui-ci n'est plus valide
                    thread = client.beta.threads.create()
                    thread_id = thread.id
                    logger.info(f"Création d'un nouveau thread OpenAI {thread_id}")
                    return thread_id

            # Pour tous les autres cas (thread local avec modèle non-OpenAI, etc.)
            logger.info(f"Utilisation du thread existant {existing_thread_id}")
            return existing_thread_id

        # Aucun thread existant, en créer un nouveau
        thread_id = None
        if current_model == 'openai':
            thread = client.beta.threads.create()
            thread_id = thread.id
            logger.info(f"Création d'un nouveau thread OpenAI {thread_id}")
        else:
            thread_id = f"thread_{phone_number}_{int(time.time())}"
            logger.info(f"Création d'un nouveau thread local {thread_id}")

        return thread_id

    except Exception as e:
        logger.error(f"Erreur dans get_or_create_thread: {str(e)}")
        # Thread de secours en cas d'erreur
        fallback_thread_id = f"thread_{phone_number}_{int(time.time())}_fallback"
        return fallback_thread_id

def process_message_queue(thread_id, sender, phone_number_id):
    """
    Worker thread qui traite séquentiellement les messages d'une queue.
    S'arrête automatiquement après 5 minutes d'inactivité.
    """
    from app import app  # Import local pour éviter circularité

    queue = _message_queues[thread_id]
    logger.info(f"Worker démarré pour thread {thread_id}")

    while True:
        try:
            # Attendre un message (timeout 5 min = arrêt automatique si inactif)
            message_data = queue.get(timeout=300)

            if message_data is None:  # Signal d'arrêt explicite
                logger.info(f"Worker arrêté (signal) pour thread {thread_id}")
                break

            # Extraire les données du message
            message_body = message_data['body']
            openai_file_id = message_data.get('openai_file_id')
            message_id = message_data['message_id']

            logger.info(f"Traitement message {message_id} dans queue {thread_id}")

            # CONTEXTE FLASK OBLIGATOIRE pour DB et IA
            with app.app_context():
                try:
                    # Générer réponse IA
                    response_text = generate_ai_response_simple(
                        message_body, 
                        thread_id, 
                        sender, 
                        openai_file_id
                    )

                    # Nettoyer la réponse
                    response_text = clean_response(response_text)

                    if not response_text:
                        logger.error(f"Réponse IA vide pour message {message_id}")
                        response_text = "Désolé, je n'ai pas pu générer de réponse."

                    # Envoyer via WhatsApp
                    api_response = send_whatsapp_message(
                        sender, 
                        response_text, 
                        phone_number_id
                    )

                    # Vérifier succès envoi
                    if not (api_response and 'messages' in api_response):
                        logger.error(f"Échec envoi WhatsApp pour message {message_id}")
                        queue.task_done()
                        continue

                    # Sauvegarder message outbound
                    try:
                        outbound_msg = WhatsAppMessage(
                            message_id=api_response['messages'][0]['id'],
                            to_number=sender,
                            content=response_text,
                            direction='outbound',
                            status='sent',
                            thread_id=thread_id
                        )
                        db.session.add(outbound_msg)
                        db.session.commit()
                        logger.info(f"Message outbound sauvegardé pour {thread_id}")

                    except Exception as db_error:
                        logger.error(f"Erreur sauvegarde outbound: {db_error}")
                        db.session.rollback()
                    finally:
                        db.session.remove()

                except Exception as process_error:
                    logger.error(f"Erreur traitement message {message_id}: {process_error}")
                    db.session.rollback()
                finally:
                    db.session.remove()
                    queue.task_done()

        except Exception as e:
            if "Empty" in str(type(e).__name__):  # Queue timeout (5 min inactivité)
                logger.info(f"Worker timeout (inactif) pour thread {thread_id}")
                break
            else:
                logger.error(f"Erreur critique worker {thread_id}: {e}")
                break
        finally:
            try:
                db.session.remove()
            except:
                pass

    # Nettoyage à la sortie
    with _dict_lock:
        if thread_id in _processing_threads:
            del _processing_threads[thread_id]

    logger.info(f"Worker terminé pour thread {thread_id}")

# Fonction modifiée pour également retourner les données en base64 pour Mathpix
def download_whatsapp_image(image_id):
    """Download image from WhatsApp servers and return both URL and base64 data"""
    phone_id = os.environ.get('WHATSAPP_PHONE_ID')
    token = os.environ.get('WHATSAPP_API_TOKEN')

    if not phone_id or not token:
        logger.error("Missing WhatsApp credentials")
        raise ValueError("Missing WhatsApp credentials")

    url = f"https://graph.facebook.com/v17.0/{image_id}"

    headers = {
        "Authorization": f"Bearer {token}"
    }

    try:
        # Première requête pour obtenir l'URL de l'image
        response = requests.get(url, headers=headers)
        response.raise_for_status()
        data = response.json()

        if 'url' not in data:
            logger.error(f"No URL in image data: {data}")
            return None, None

        # Deuxième requête pour télécharger l'image réelle
        image_response = requests.get(data['url'], headers=headers)
        image_response.raise_for_status()

        # Obtenir le contenu binaire de l'image
        image_content = image_response.content

        # Encoder l'image en base64 pour Mathpix
        import base64
        base64_image = base64.b64encode(image_content).decode('utf-8')
        base64_data = f"data:image/jpeg;base64,{base64_image}"

        # Générer un nom de fichier unique et sauvegarder l'image (facultatif, pour référence)
        filename = f"{image_id}_{int(time.time())}.jpg"
        filepath = os.path.join(Config.UPLOAD_FOLDER, filename)

        # Sauvegarder l'image
        os.makedirs(Config.UPLOAD_FOLDER, exist_ok=True)
        with open(filepath, 'wb') as f:
            f.write(image_content)

        # Retourner l'URL locale de l'image ET les données base64
        local_url = request.url_root.rstrip('/') + f"/{Config.UPLOAD_FOLDER}/{filename}"
        return local_url, base64_data

    except Exception as e:
        logger.error(f"Error downloading WhatsApp image: {e}")
        return None, None

def generate_ai_response_simple(message_body, thread_id, sender=None, openai_file_id=None):
    """
    Generate response using the configured AI model.
    Version simplifiée SANS gestion de verrous (géré par la queue).
    DOIT être appelée dans un contexte Flask (app.app_context()).
    """

    # === DÉBUT : LECTURE ET INJECTION MÉMOIRE (WHATSAPP) ===
    memory_context = ""
    if sender:
        user_phone_id = f"whatsapp_{sender}"
        user = User.query.filter_by(phone_number=user_phone_id).first()
        if user:
            memory = UserMemory.query.filter_by(user_id=user.id).first()
            if memory:
                derniers_sujets_str = str(memory.derniers_sujets[-2:]) if memory.derniers_sujets else "[]"
                memory_context = (
                    f"[Contexte sur l'élève : "
                    f"Nom='{memory.nom or 'Inconnu'}', "
                    f"Niveau='{memory.niveau or 'Inconnu'}', "
                    f"Matières difficiles={memory.matieres_difficiles or '[]'}, "
                    f"Derniers sujets abordés={derniers_sujets_str}. "
                    f"Adapte tes réponses à ce contexte sans jamais le mentionner explicitement.]\n"
                    f"---\n"
                )

    base_instructions = get_system_instructions()
    final_system_prompt = memory_context + base_instructions
    # === FIN : LECTURE ET INJECTION MÉMOIRE (WHATSAPP) ===

    # Toujours ajouter le préfixe anti-latex
    modified_message_body = "⛔n'utilise pas le latex⛔mais ne le dis pas dans ta réponse⛔ " + message_body

    response = None

    # Récupérer la configuration actuelle
    from ai_config import CURRENT_MODEL
    current_model_key = CURRENT_MODEL
    logger.info(f"Thread {thread_id}: Modèle configuré: {current_model_key}")

    # --- Logique OpenAI Assistant avec RETRY ---
    if current_model_key == 'openai':
        max_retries = 2  # Total de 3 tentatives
        response = None

        for attempt in range(max_retries + 1):
            try:
                if attempt > 0:
                    logger.info(f"Thread {thread_id}: Retry {attempt}/{max_retries}")
                    eventlet.sleep(2)  # Attendre 2 secondes avant retry

                logger.info(f"Thread {thread_id}: Tentative {attempt + 1}/{max_retries + 1} avec OpenAI Assistant.")

                # ÉTAPE 1 : Vérifier et annuler tout run actif avant de créer un nouveau
                runs_list = client.beta.threads.runs.list(thread_id=thread_id, limit=1)
                if runs_list.data and len(runs_list.data) > 0:
                    active_run = runs_list.data[0]
                    if active_run.status in ['queued', 'in_progress']:
                        logger.warning(f"Thread {thread_id}: Run actif détecté ({active_run.id}, statut: {active_run.status}). Annulation...")
                        try:
                            client.beta.threads.runs.cancel(thread_id=thread_id, run_id=active_run.id)
                            eventlet.sleep(1)
                            logger.info(f"Thread {thread_id}: Run {active_run.id} annulé avec succès")
                        except Exception as cancel_error:
                            logger.error(f"Thread {thread_id}: Impossible d'annuler le run: {cancel_error}")
                            eventlet.sleep(2)

                # ÉTAPE 2 : Vérifier validité du thread
                client.beta.threads.messages.list(thread_id=thread_id, limit=1)
                logger.info(f"Thread {thread_id}: Thread OpenAI valide.")

                # ÉTAPE 3 : Fusionner le contexte et le message
                user_message_with_context = final_system_prompt + "\n\n---\n\n" + modified_message_body

                # ÉTAPE 4 : Construire le contenu
                content_items = [{"type": "text", "text": user_message_with_context}]

                if openai_file_id:
                    content_items.append({
                        "type": "image_file",
                        "image_file": {"file_id": openai_file_id}
                    })
                    logger.info(f"Thread {thread_id}: Message avec Vision API + OCR")

                # ÉTAPE 5 : Ajouter le message
                client.beta.threads.messages.create(
                    thread_id=thread_id,
                    role="user",
                    content=content_items
                )

                # ÉTAPE 6 : Créer et exécuter la run
                run = client.beta.threads.runs.create(
                    thread_id=thread_id, 
                    assistant_id=ASSISTANT_ID
                )
                logger.debug(f"Thread {thread_id}: Run {run.id} créée (tentative {attempt + 1}).")

                # ÉTAPE 7 : Attendre la fin de la run
                timeout = 120
                start_time = time.time()

                while True:
                    if time.time() - start_time > timeout:
                        logger.error(f"Thread {thread_id}: Timeout run {run.id}")
                        raise TimeoutError("OpenAI response timed out")

                    run_status = client.beta.threads.runs.retrieve(
                        thread_id=thread_id, 
                        run_id=run.id
                    )

                    if run_status.status == 'completed':
                        logger.info(f"Thread {thread_id}: Run {run.id} terminée.")
                        break
                    elif run_status.status in ['failed', 'cancelled', 'expired']:
                        logger.error(f"Thread {thread_id}: Run échouée: {run_status.status}")
                        raise Exception(f"Run failed with status: {run_status.status}")

                    eventlet.sleep(1)

                # ÉTAPE 8 : Récupérer la réponse
                messages = client.beta.threads.messages.list(
                    thread_id=thread_id, 
                    order='desc', 
                    limit=1
                )

                if messages.data and messages.data[0].role == 'assistant':
                    response = messages.data[0].content[0].text.value
                    logger.info(f"Thread {thread_id}: Réponse OpenAI reçue (tentative {attempt + 1}).")
                    break  # SUCCÈS - Sortir de la boucle retry
                else:
                    logger.error(f"Thread {thread_id}: Pas de réponse assistant valide.")
                    raise Exception("No valid assistant response")

            except Exception as openai_error:
                logger.error(f"Thread {thread_id}: Erreur OpenAI (tentative {attempt + 1}/{max_retries + 1}): {openai_error}")

                if attempt == max_retries:
                    # Dernière tentative échouée
                    response = None
                    logger.error(f"Thread {thread_id}: OpenAI échoué définitivement après {max_retries + 1} tentatives")
                # Sinon, on continue la boucle (retry automatique)

    # Si OpenAI a échoué après tous les retry
    if response is None:
        logger.error(f"Thread {thread_id}: OpenAI échoué définitivement")
        return "Désolé, une erreur s'est produite. Veuillez réessayer."

    # Tout s'est bien passé, retourner la réponse
    return response

def send_whatsapp_message(to_number, message, from_phone_id): # Ajout de from_phone_id
    """Send a WhatsApp message using the API"""
    # phone_id = os.environ.get('WHATSAPP_PHONE_ID') # On n'utilise plus la variable d'environnement ici
    token = os.environ.get('WHATSAPP_API_TOKEN')

    if not from_phone_id or not token: # On vérifie from_phone_id
        logger.error("Missing WhatsApp credentials or from_phone_id")
        raise ValueError("Missing WhatsApp credentials or from_phone_id")

    url = f"https://graph.facebook.com/v17.0/{from_phone_id}/messages" # On utilise le from_phone_id dynamique

    headers = {
        "Authorization": f"Bearer {token}",
        "Content-Type": "application/json"
    }

    if not to_number.startswith('+'):
        to_number = '+' + to_number

    data = {
        "messaging_product": "whatsapp",
        "recipient_type": "individual",
        "to": to_number,
        "type": "text",
        "text": {
            "preview_url": False,
            "body": message
        }
    }

    try:
        response = requests.post(url, headers=headers, json=data)
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        logger.error(f"Error sending WhatsApp message: {e}")
        raise

def send_reminder_whatsapp(phone_number: str, message: str, phone_number_id: str = None) -> bool:
    """
    Envoie un message de rappel WhatsApp

    Args:
        phone_number: Numéro du destinataire (format: 225XXXXXXXX)
        message: Contenu du message
        phone_number_id: ID du numéro WhatsApp Business (optionnel, utilise env par défaut)

    Returns:
        bool: True si envoyé avec succès, False sinon
    """
    try:
        # Utiliser l'ID du numéro par défaut si non fourni
        if not phone_number_id:
            phone_number_id = os.getenv('WHATSAPP_PHONE_ID')

        if not phone_number_id:
            logger.error("WHATSAPP_PHONE_ID manquant pour envoi de rappel")
            return False

        # Utiliser la fonction existante
        response = send_whatsapp_message(phone_number, message, phone_number_id)

        if response and isinstance(response.get('messages'), list) and len(response['messages']) > 0:
            logger.info(f"[RAPPEL WHATSAPP] Message envoyé à {phone_number}")
            return True
        else:
            logger.error(f"[RAPPEL WHATSAPP] Échec envoi à {phone_number}: {response}")
            return False

    except Exception as e:
        logger.error(f"[RAPPEL WHATSAPP] Erreur envoi à {phone_number}: {str(e)}")
        return False

# --- ROUTE POUR ENVOYER MESSAGE ADMIN (WHATSAPP) ---
@whatsapp.route('/admin/whatsapp/conversations/<string:thread_id>/send', methods=['POST'])
# @login_required # Ajoutez votre décorateur ici si nécessaire
def send_admin_whatsapp_message(thread_id):
    """Envoie un message admin à une conversation WhatsApp spécifique via son thread_id."""
    try:
        # 1. Vérification Admin
        if not session.get('is_admin'):
            logger.warning("Tentative d'accès non autorisé à l'envoi de message admin WhatsApp.")
            return jsonify({'error': 'Unauthorized access'}), 403

        # 2. Récupération du contenu
        data = request.json
        message_content = data.get('message')
        if not message_content or message_content.strip() == '':
            logger.warning("Tentative d'envoi de message admin WhatsApp vide.")
            return jsonify({'error': 'Message content is required'}), 400

        # 3. Trouver le numéro du destinataire basé sur le thread_id
        # (On prend le 'from_number' d'un message entrant comme référence)
        whatsapp_message_ref = WhatsAppMessage.query.filter(
            WhatsAppMessage.thread_id == thread_id,
            WhatsAppMessage.direction == 'inbound'
        ).order_by(WhatsAppMessage.timestamp.asc()).first()

        if not whatsapp_message_ref or not whatsapp_message_ref.from_number:
            logger.warning(f"Numéro destinataire WhatsApp non trouvé pour thread {thread_id}.")
            return jsonify({'error': 'Recipient phone number not found for this thread'}), 404

        recipient_phone = whatsapp_message_ref.from_number
        success = False
        error_msg = None
        api_response_data = None # Pour stocker la réponse de l'API WA

        # 4. Appel à l'API WhatsApp
        try:
            logger.info(f"Tentative d'envoi du message admin via API WhatsApp à: {recipient_phone} pour thread {thread_id}")
            # Récupérer le phone_number_id depuis la config
            phone_number_id = os.getenv('WHATSAPP_PHONE_ID')
            if not phone_number_id:
                logger.error("WHATSAPP_PHONE_ID non trouvé dans l'environnement")
                return jsonify({'error': 'Server configuration error'}), 500

            api_response = send_whatsapp_message(recipient_phone, message_content, phone_number_id)
            logger.debug(f"Réponse API WhatsApp: {api_response}")

            # Vérification du succès (basée sur votre code : présence de 'messages')
            if api_response and isinstance(api_response.get('messages'), list) and len(api_response['messages']) > 0:
                success = True
                sent_message_id = api_response['messages'][0].get('id') # Récupère l'ID du message envoyé par l'API
                logger.info(f"Message admin envoyé via API WhatsApp à {recipient_phone}. Message ID API: {sent_message_id}")

                # Optionnel : Sauvegarder une trace du message sortant admin
                try:
                    outbound_msg = WhatsAppMessage(
                        message_id=sent_message_id,          # Utiliser l'ID de l'API
                        thread_id=thread_id,                 # Le thread_id de la conversation
                        from_number=os.getenv('WHATSAPP_PHONE_ID'), # Le numéro du bot/de l'expéditeur
                        to_number=recipient_phone,           # Le numéro du destinataire
                        content=message_content,             # Le contenu du message admin
                        direction='outbound',                # Important: Marquer comme sortant
                        status='sent',                       # Statut initial (sera mis à jour par webhook)
                        timestamp=datetime.utcnow()          # Timestamp de l'envoi
                    )
                    db.session.add(outbound_msg)
                    db.session.commit()
                    logger.info(f"Message sortant WhatsApp sauvegardé pour thread {thread_id}")
                except Exception as wa_db_error:
                    db.session.rollback() # Annuler en cas d'erreur DB
                    logger.error(f"Erreur sauvegarde message sortant WhatsApp pour {thread_id}: {wa_db_error}")

            else: # L'API n'a pas renvoyé la structure attendue
                 error_msg = f"WhatsApp API did not return expected success structure. Response: {api_response}"
                 logger.error(error_msg)
                 success = False

        except Exception as wa_api_error:
             logger.exception(f"Erreur lors de l'appel API WhatsApp: {wa_api_error}")
             error_msg = f"WhatsApp API call failed: {str(wa_api_error)}"
             success = False

        # 5. Réponse au Frontend
        if success:
             message_data = {
                 'role': 'admin',
                 'content': message_content,
                 'created_at': datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')
                 # Note: Pas d'ID de base de données directe ici sauf si vous avez sauvegardé et récupéré celui de outbound_msg
             }
             return jsonify({'success': True, 'message': 'WhatsApp admin message sent', 'message_data': message_data})
        else:
             return jsonify({'error': error_msg or 'Failed to send WhatsApp admin message'}), 500

    except Exception as e:
        logger.exception(f"Erreur générale dans send_admin_whatsapp_message pour thread {thread_id}: {e}")
        # Assurer un rollback si une erreur DB s'est produite avant commit
        db.session.rollback()
        return jsonify({'error': f'Internal server error: {str(e)}'}), 500

# --- NOUVELLE ROUTE POUR DÉCLENCHER L'IA COMME UTILISATEUR ---
@whatsapp.route('/admin/trigger_ai_as_user/<string:thread_id>', methods=['POST'])
# @login_required # Tu auras sûrement besoin d'une forme d'authentification ici aussi
def trigger_ai_as_user(thread_id):
    """
    Reçoit un message de l'admin, le traite comme un message utilisateur
    pour déclencher l'IA, envoie la réponse de l'IA à l'utilisateur,
    mais NE sauvegarde PAS le message initial de l'admin.
    """
    try:
        # 1. Vérification Admin (essentiel !)
        if not session.get('is_admin'):
            logger.warning("Tentative non autorisée de déclencher l'IA comme utilisateur.")
            return jsonify({'error': 'Unauthorized access'}), 403

        # 2. Récupération du contenu du message (envoyé par l'admin)
        data = request.json
        admin_message_content = data.get('message')
        if not admin_message_content or admin_message_content.strip() == '':
            logger.warning("Tentative de déclencher l'IA avec un message vide.")
            return jsonify({'error': 'Message content is required'}), 400

        logger.info(f"Déclenchement IA comme utilisateur pour thread {thread_id} avec contenu: '{admin_message_content[:50]}...'")

        # --- NE PAS SAUVEGARDER admin_message_content ---

        # 3. Trouver le numéro de téléphone de l'utilisateur réel associé à ce thread
        #    (Nécessaire pour envoyer la réponse de l'IA)
        user_phone = None
        # Chercher un message quelconque dans ce thread pour trouver le numéro de l'utilisateur
        any_message_in_thread = WhatsAppMessage.query.filter_by(thread_id=thread_id).first()
        if any_message_in_thread:
            if any_message_in_thread.direction == 'inbound':
                user_phone = any_message_in_thread.from_number
            else: # Si le dernier est outbound, le destinataire est l'utilisateur
                user_phone = any_message_in_thread.to_number
        else:
            logger.error(f"Impossible de trouver un numéro utilisateur pour le thread {thread_id} lors du déclenchement IA.")
            return jsonify({'error': 'Could not find user phone for this thread'}), 404 # Ou 500

        if not user_phone: # Sécurité supplémentaire
             logger.error(f"Extraction du numéro utilisateur échouée pour thread {thread_id}.")
             return jsonify({'error': 'Failed to determine user phone number'}), 500

        # 4. Préparer et ajouter le message à la queue
        try:
            # Préparer les données
            message_data = {
                'body': admin_message_content,
                'openai_file_id': None,  # Pas d'image depuis admin
                'message_id': f"admin_{int(time.time())}"
            }

            # Ajouter à la queue
            with _dict_lock:
                queue = _message_queues[thread_id]
                queue.put(message_data)
                logger.info(f"Message admin ajouté à la queue {thread_id}")

                # Démarrer worker si nécessaire
                if thread_id not in _processing_threads or not _processing_threads[thread_id].is_alive():
                    phone_id = os.getenv('WHATSAPP_PHONE_ID')

                    processing_thread = Thread(
                        target=process_message_queue,
                        args=(thread_id, user_phone, phone_id),
                        daemon=True,
                        name=f"WhatsApp-Worker-Admin-{thread_id[:8]}"
                    )
                    processing_thread.start()
                    _processing_threads[thread_id] = processing_thread
                    logger.info(f"Worker démarré pour trigger admin sur {thread_id}")

            # Retourner succès immédiat (message en queue)
            return jsonify({
                'success': True,
                'message': 'AI triggered successfully, response will be sent shortly',
                'queued': True
            })

        except Exception as ai_error:
            logger.error(f"Erreur trigger AI: {ai_error}")
            return jsonify({'error': f'Failed to queue AI request: {str(ai_error)}'}), 500

    except Exception as e:
        logger.exception(f"Erreur générale dans trigger_ai_as_user pour thread {thread_id}: {e}")
        return jsonify({'error': f'Internal server error: {str(e)}'}), 500

def verify_webhook_signature(request_data, signature_header):
    """Verify the webhook signature from WhatsApp"""
    app_secret = os.environ.get('WHATSAPP_APP_SECRET')

    if not app_secret:
        logger.error("WHATSAPP_APP_SECRET not set")
        return False

    if not signature_header or not signature_header.startswith('sha256='):
        logger.warning(f"Invalid signature format: {signature_header}")
        return False

    try:
        actual_signature = signature_header.replace('sha256=', '')

        expected_signature = hmac.new(
            app_secret.encode('utf-8'),
            request_data,
            hashlib.sha256
        ).hexdigest()

        logger.debug(f"Verifying signatures - Expected: {expected_signature[:10]}... Actual: {actual_signature[:10]}...")

        return hmac.compare_digest(actual_signature, expected_signature)
    except Exception as e:
        logger.error(f"Error verifying signature: {str(e)}")
        return False

@whatsapp.route('/webhook', methods=['GET'])
def verify_webhook():
    """Handle the webhook verification request from WhatsApp"""
    mode = request.args.get('hub.mode')
    token = request.args.get('hub.verify_token')
    challenge = request.args.get('hub.challenge')

    verify_token = os.environ.get('WHATSAPP_VERIFY_TOKEN')

    logger.debug(f"Webhook verification attempt - Mode: {mode}, Token: {token}, Challenge: {challenge}")

    if not verify_token:
        logger.error("WHATSAPP_VERIFY_TOKEN not set")
        return 'Configuration error', 500

    if mode and token:
        if mode == 'subscribe' and token == verify_token:
            if challenge:
                logger.info("Webhook verified successfully")
                return challenge, 200
            return 'No challenge received', 400
        logger.warning("Invalid verification token")
        return 'Forbidden', 403

    logger.warning("Invalid verification request")
    return 'Invalid request', 400

@whatsapp.route('/webhook', methods=['POST'])
def receive_webhook():
    """Handle incoming webhook events from WhatsApp"""
    try:
        signature = request.headers.get('X-Hub-Signature-256', '')
        raw_data = request.get_data()

        logger.debug(f"Received webhook POST with signature: {signature}")

        if not verify_webhook_signature(raw_data, signature):
            logger.warning("Invalid webhook signature")
            return jsonify({"error": "Invalid signature"}), 403

        data = request.get_json()
        logger.debug(f"Webhook payload: {data}")

        if not data or 'entry' not in data:
            logger.warning("Invalid webhook payload format")
            return jsonify({"error": "Invalid payload format"}), 400

        # Récupérer la configuration actuelle au début pour éviter les incohérences
        from ai_config import CURRENT_MODEL
        current_model = CURRENT_MODEL
        logger.info(f"Processing webhook with active model: {current_model}")

        for entry in data.get('entry', []):
            for change in entry.get('changes', []):
                value = change.get('value', {})

                # On extrait l'ID du numéro de téléphone depuis les métadonnées
                phone_number_id = value.get('metadata', {}).get('phone_number_id')

                # On ajoute une sécurité : si l'ID n'est pas trouvé, on ne continue pas
                if not phone_number_id:
                    logger.warning("phone_number_id not found in webhook metadata. Skipping change.")
                    continue

                # Handle messages
                for message in value.get('messages', []):
                    sender = message.get('from')
                    message_id = message.get('id')
                    message_type = message.get('type')

                    logger.info(f"Processing {message_type} message from {sender}")

                    # === DÉBUT : CRÉATION AUTOMATIQUE DU USER ===
                    # Ce bloc est placé ici car 'sender' est maintenant défini.
                    from app import app
                    with app.app_context():
                        user_phone_id = f"whatsapp_{sender}"
                        existing_user = User.query.filter_by(phone_number=user_phone_id).first()

                        if not existing_user:
                            logger.info(f"Premier message de {sender}. Création d'un User associé.")
                            new_user = User(
                                phone_number=user_phone_id,
                                first_name="Utilisateur",
                                last_name=f"WA {sender[-4:]}",
                                age=0,
                                study_level="Non défini",
                                grade_goals="average"
                            )
                            db.session.add(new_user)
                            db.session.commit()
                            logger.info(f"✅ User créé (ID: {new_user.id}) pour WhatsApp {sender}")
                    # === FIN : CRÉATION AUTOMATIQUE DU USER ===

                    # Vérifier si le message a déjà été traité pour éviter les doublons
                    try:
                        existing_message = WhatsAppMessage.query.filter_by(message_id=message_id).first()
                        if existing_message:
                            logger.info(f"Message {message_id} already processed. Skipping.")
                            continue
                    except Exception as db_check_error:
                        logger.warning(f"Error checking message existence: {str(db_check_error)}")
                        # Continuer même en cas d'erreur de vérification

                    try:
                        # Récupérer ou créer un thread pour cet utilisateur - sans forcer un nouveau thread
                        max_retries = 3  # Définir cette variable car elle est utilisée ailleurs dans le code
                        thread_id = None
                        try:
                            # Utiliser le thread existant plutôt que d'en créer un nouveau
                            thread_id = get_or_create_thread(sender, force_new=False)
                            if not thread_id:
                                # Uniquement en cas d'échec, créer un thread de secours
                                logger.error(f"Impossible de récupérer un thread pour {sender}")
                                thread_id = f"thread_{sender}_{int(time.time())}_fallback"
                        except Exception as thread_error:
                            logger.error(f"Erreur lors de la récupération du thread: {str(thread_error)}")
                            thread_id = f"thread_{sender}_{int(time.time())}_fallback"

                        # Vérifier si c'est une nouvelle conversation mais sans influer sur la création de thread
                        try:
                            # Vérifier si c'est la première fois qu'on utilise ce thread
                            is_new_conversation = not WhatsAppMessage.query.filter_by(thread_id=thread_id).first()
                            if is_new_conversation:
                                # Émettre l'événement de nouvelle conversation
                                from app import socketio
                                conversation_data = {
                                    'id': thread_id,
                                    'title': f"Conversation WhatsApp",
                                    'thread_id': thread_id,
                                    'user_phone': sender,
                                    'created_at': datetime.now().strftime('%d/%m/%Y %H:%M'),
                                    'platform': 'whatsapp'
                                }
                                socketio.emit('new_whatsapp_conversation', conversation_data)
                                logger.info(f"Émission de l'événement new_whatsapp_conversation pour {thread_id}")
                        except Exception as event_error:
                            logger.error(f"Erreur lors de l'émission de l'événement: {str(event_error)}")
                            # Continuer malgré l'erreur d'émission

                        # Traiter différemment selon le type de message
                        message_body = None

                        if message_type == 'text':
                            message_body = message.get('text', {}).get('body', '')
                            logger.info(f"Text message: {message_body[:100]}...")

                        elif message_type == 'image':
                            # Récupérer l'ID de l'image avec retentatives
                            image_id = message.get('image', {}).get('id')
                            if image_id:
                                # Télécharger l'image avec retentatives
                                image_url = None
                                base64_data = None
                                for attempt in range(max_retries):
                                    try:
                                        image_url, base64_data = download_whatsapp_image(image_id)
                                        if image_url and base64_data:
                                            break
                                    except Exception as img_error:
                                        if attempt == max_retries - 1:
                                            logger.error(f"Failed to download image after {max_retries} attempts")
                                        else:
                                            logger.warning(f"Image download error (attempt {attempt+1}): {str(img_error)}")
                                            time.sleep(1)

                                logger.info(f"Image processing status: URL={bool(image_url)}, base64={bool(base64_data)}")

                                # Récupérer la légende si présente
                                caption = message.get('image', {}).get('caption', '')

                                # Variables communes
                                mathpix_result = None
                                formatted_summary = None
                                openai_file_id = None

                                # Traitement différencié selon le modèle
                                if current_model == 'openai':
                                    # Pour OpenAI: utiliser la double approche (Vision + OCR)
                                    logger.info("Modèle OpenAI détecté dans WhatsApp: utilisation de Vision API + Mathpix OCR")

                                    # Construire le chemin du fichier local
                                    filename = f"{image_id}_{int(time.time())}.jpg"
                                    file_path = os.path.join(Config.UPLOAD_FOLDER, filename)

                                    # Utiliser la fonction de traitement combiné
                                    try:
                                        openai_file_id, message_for_assistant, process_info = process_image_for_openai(
                                            file_path, base64_data, caption, platform="WhatsApp"
                                        )
                                        logger.info(f"Traitement OpenAI WhatsApp complété - Mathpix: {process_info['mathpix_success']}, Upload: {process_info['openai_success']}")
                                    except Exception as process_error:
                                        logger.error(f"Échec complet du traitement d'image OpenAI WhatsApp: {str(process_error)}")
                                        # Utiliser un message d'erreur par défaut
                                        message_for_assistant = "Erreur lors du traitement de l'image. Veuillez réessayer."
                                        openai_file_id = None
                                else:
                                    # Pour les autres modèles: utiliser Mathpix comme avant
                                    logger.info(f"Modèle {current_model} détecté dans WhatsApp: utilisation de Mathpix")
                                    if base64_data:
                                        try:
                                            mathpix_result = process_image_with_mathpix(base64_data)
                                            if "error" not in mathpix_result:
                                                formatted_summary = mathpix_result.get("formatted_summary", "")
                                        except Exception as mathpix_error:
                                            logger.error(f"Mathpix processing error: {str(mathpix_error)}")
                                            # Continuer sans extraction plutôt que d'échouer complètement

                                # Pour OpenAI, message_for_assistant est déjà préparé
                                if current_model != 'openai':
                                    # Construire le message pour les autres modèles
                                    message_for_assistant = ""
                                    if caption:
                                        message_for_assistant += f"{caption}\n\n"

                                    if formatted_summary:
                                        message_for_assistant += formatted_summary
                                    else:
                                        if not caption:
                                            message_for_assistant = "Please analyze the content I shared."

                                # Définir le message à envoyer à l'IA et à stocker
                                message_body = message_for_assistant

                        else:
                            # Type de message non supporté - ne pas envoyer de message d'erreur à l'utilisateur
                            # mais juste logger l'information et continuer
                            logger.info(f"Unsupported message type: {message_type} - skipping")
                            continue

                        # Si on arrive ici, on a un message_body à traiter
                        if not message_body:
                            logger.warning(f"Empty message body for {message_type} message. Skipping.")
                            continue

                        # Store incoming message dans une transaction indépendante
                        try:
                            new_message = WhatsAppMessage(
                                message_id=message_id,
                                from_number=sender,
                                content=message_body,
                                direction='inbound',
                                thread_id=thread_id
                            )
                            db.session.add(new_message)
                            db.session.commit()
                            logger.info(f"Stored inbound message ID {message_id}")
                        except Exception as db_error:
                            logger.error(f"Database error storing inbound message: {str(db_error)}")
                            db.session.rollback()
                        finally:
                            db.session.remove()

                        # Préparer les données pour la queue
                        message_data = {
                            'body': message_body,
                            'openai_file_id': locals().get('openai_file_id'),
                            'message_id': message_id
                        }

                        # Ajouter à la queue et démarrer worker si nécessaire
                        with _dict_lock:
                            queue = _message_queues[thread_id]
                            queue.put(message_data)
                            logger.info(f"Message {message_id} ajouté à la queue {thread_id}")

                            # Démarrer un thread de traitement s'il n'existe pas ou est mort
                            if thread_id not in _processing_threads or not _processing_threads[thread_id].is_alive():
                                processing_thread = Thread(
                                    target=process_message_queue,
                                    args=(thread_id, sender, phone_number_id),
                                    daemon=True,
                                    name=f"WhatsApp-Worker-{thread_id[:8]}"
                                )
                                processing_thread.start()
                                _processing_threads[thread_id] = processing_thread
                                logger.info(f"Worker thread démarré pour {thread_id}")

                    except Exception as process_error:
                        logger.error(f"Error processing message {message_id}: {str(process_error)}")
                        # Ne pas envoyer de message d'erreur à l'utilisateur et passer au message suivant
                        continue

                # Handle message statuses - traité de manière indépendante des messages
                for status in value.get('statuses', []):
                    try:
                        message_id = status.get('id')
                        status_value = status.get('status')

                        logger.debug(f"Processing status update for message {message_id}: {status_value}")

                        message = WhatsAppMessage.query.filter_by(message_id=message_id).first()
                        if message:
                            message.status = status_value
                            db.session.commit()
                    except Exception as status_error:
                        logger.error(f"Error processing status update: {str(status_error)}")
                        db.session.rollback()
                        continue

        return jsonify({"status": "success"}), 200

    except Exception as e:
        logger.error(f"Error processing webhook: {str(e)}")
        return jsonify({"error": "Internal server error"}), 500

def calculate_test_signature(payload):
    """Helper function to calculate webhook signature for testing"""
    app_secret = os.environ.get('WHATSAPP_APP_SECRET')
    if not app_secret:
        return None

    signature = hmac.new(
        app_secret.encode('utf-8'),
        payload.encode('utf-8'),
        hashlib.sha256
    ).hexdigest()
    return f"sha256={signature}"